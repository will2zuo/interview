主要记录一些平时面试遇到的题目

### PHP

#### PHP 是什么

> PHP（"PHP:Hypertext Preprocessor"，超文本预处理器），基于服务端创建动态网站的脚本语言

#### PHP数据类型

1. 基本类型
   - 布尔型（boolean）：true 和 false 两个值
   - 整型（integer）
   - 浮点型（float）
   - 字符串（string）
2. 复合类型
   - 数组（array）
   - 对象（object）
3. 特殊类型
   - 资源（resource）：存放 PHP 外部数据，比如数据库、文件等
   - Null 类型：只有一个值 null，不能运算

#### 常用的全局变量 $_SERVER

```php
// 目录根目录
	$_SERVER['DOCUMENT_ROOT']
// 请求头部
	$_SERVER['HTTP_HOST']
// 用户 ip 地址
	$_SERVER['REMOTE_ADDR']
// 服务器的 ip 地址
	$_SERVER['SERVER_ADDR']
// 服务器主机名称
	$_SERVER['SERVER_NAME']
// 当前页面的前一页
	$_SERVER['HTTP_REFERER']
// 判断接收的数据是 post 还是 get
	$_SERVER['REQUEST_METHOD']
```

#### PHP 常用的超全局变量

```php
// get 传送方式
	$_GET
// post 传送方式
	$_POST
// 可以接收到 get 和 post 两种方式的值
	$_REQUEST
// 引用全局作用域中可用的全部变量
	$_GLOBALS
// 上传文件使用
	$_FILE
// 系统环境变量
	$_SERVER
// 用于会话控制
	$_COOKIE
// 用于会话控制
	$_SESSION
// 服务器环境变量
	$_ENV
```

#### 比较 include 和 require 

- include 引用不存在的文件会产生一个警告但是程序会继续执行；require 引用不存在的文件会导致一个致命的错误，程序停止执行
- include 执行时文件吗每次都要进行读取；require 文件只处理一次，所以在引用的文件较大时，require 的效率更高

#### 比较 get 和 post 两种传输方式（常规答案）

- 数据传输大小： get 传输数据的大小是 2kb，而 post 一般是没有限制的，但是会受内存大小影响，一般通过修改 php.ini 配置文件来修改
- 数据传输方式： get 是通过 url 传递参数的，在 url 中可以看到参数；post 是在表单中使用 post 方法提交
- 数据安全性：get 参数可见，容易被攻击
- 缓存： get 可以被缓存， post 不能被缓存

#### echo、print、print_r 的区别

- echo 可以输出一个或者多个变量
- print 只能打印一个变量
- print_r 是一个函数，打印的是复合类型的变量，比如 数组、对象

#### 传值赋值和引用赋值的区别

- 传值赋值是将变量里的内容赋值一份，被赋值的变量不会被影响
- 引用赋值是将两个变量指向同一个内存空间，只要其中一个变量改变就会影响到另一个变量

#### 将 1234567890 改为 1,234,567,890

```php
<?php
	$str = '1234567890';
	$strrev = strrev($str);
	$chunk = chunk_split($strrev, 3, ',');
	$result = strrev($chunk);
	$result = substr($result, 1);
	echo $result;
```

#### session 和 cookie 的区别

- cookie 的数据存放在客户端，session 的数据存放在服务器
- cookie 安全性较差，别人可以分析放在本地的 cookie 进行 cookie 欺骗（CSRF，跨站伪造请求攻击）
- session 会在一定时间内保存在服务器上，当大量的 session 存在，会影响服务器的性能
- 单个 cookie 保存的数据长度不能超过 4kb ，很多浏览器都限制一个网址最多能保存 20 个 cookie

#### 如何设置 session 的过期时间

```php
session_set_cookie_params()
```

#### PHP 常见的设计模型

1. 策略模式
   - 是对象的行为模式，是对一组算法的封装，动态的选择需要的算法使用
2. 工厂模式
   - 最常用的实例化对象模式，是用工厂的方法代替 new 操作的一种方式
3. 单例模式
   - 保证某个类只有一个实例，而且自动实例化并向整个系统提供这个实例
   - 只实例化一次，避免大量的 new 操作，消耗系统和内存资源
   - 饿汉模式：在类初始化就自行实例化
   - 懒汉模式：只是在第一次调用的时候进行实例化
4. 适配器模式
   - 将各种截然不同的函数接口封装成一个统一的 API
5. 注册模式
   - 解决全局共享和交换对象
6. 观察者模式
   - 当一个对象发生变化时，依赖它的对象都会收到小心，并自动更新（比如 事件）

#### 数组常用的函数

```php
array_merge(); // 合并数组
array_push(); // 往数组后追加
array_unique(); // 去重
array_keys(); // 获取数组的 key 值
array_values(); // 获取数据的 value 值
array_filter(); // 去空
in_array(); // 数组包含
count(); // 计算数组的长度
```

#### 面对对象的特征

1. **封装**：只需要知道这个类是做什么的，不需要关心怎么实现
2. **继承**：子类可以继承父类的属性和方法，也可以重写或者新增属性和方法，增加了代码的可重用
3. **多态**：同一个类的不同对象使用同一个方法可以得到不同的结果，增加了灵活性和重用性

#### 面对对象的五大原则

1. **单一职责原则**：一个类的功能单一
2. **开放封闭原则**：在扩展上是开放的，在更改性能方面是封闭的
3. **替换原则**：子类可以替换父类出现在父类可以出现的地方
4. **依赖原则**：具体依赖抽象，上层依赖下层
5. **接口隔离原则**：模块间要通过接口隔离开，而不是通过具体的类强耦合

#### PHP7 比 PHP5 性能高

1. 变量存储字节看小，减少内存占用，提升变量的操作速度
2. 改善数组结构，数组元素和 hash 映射表分配在同一内存，降低内存占用，提高了 cpu 的缓存命中率
3. 改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高了执行效率

#### PHP7 和 PHP5 的区别

1. 性能提升了 **2** 倍
2. 全面一致的支持 64 位
3. 之前出现的致命错误，现在改为抛出异常
4. 增加了空结合操作符
5. 增加了函数返回类型声明
6. 增加了标量类型声明
7. 增加了匿名函数
8. 移除了一些老的不再支持的SPAI（服务器端应用编程端口）和扩展（mysql mssql）
9. 可以定义常量数组

#### php.ini 的优化

1. 内存分配
2. zend opcache 缓存操作码
3. 设置文件上传大小
4. 设置进程超时时间
5. 处理会话（将会话存入缓存中而不是数据库）
6. 缓冲输出（用最少的块输出最多的数据）

#### 抽象和接口的区别

1. 接口的访问控制必须是 public，抽象三种都可以
2. 继承接口用 implement，继承抽象用 extends
3. 声明接口用 interface，声明抽象用 abstract
4. 接口没有构造函数
5. 一个类可以继承多个接口，只能继承一个抽象

#### 抽象

1. 里面至少有一个抽象方法 abstract
2. 只声明了方面，没有具体实现
3. 被继承时，子类必须实现继承的所有方法
4. 子类的访问控制必须比父类更加宽松

#### 接口

1. 定义的所有方法必须是公有的
2. 用 interface 来定义接口，用implement 来继承接口
3. 实现接口必须实现接口里的所有方法
4. 可以继承多个接口，用逗号分隔

#### final 关键字

1. 类声明 final 关键字，不能被继承
2. 方法声明 final 关键字，不能被重写

#### yield 生成器

及时计算并产出后续值，不占用宝贵的内存，简单的迭代器

#### 访问修饰符

```php
public/protected/private
```

#### PHP 常用的魔术常量

```php
1. __FILE__ // 完整文件路径或文件名
2. __LINE__ // 当前行号
3. __DIR__ // 文件所有目录
4. __FUNCTION__ // 函数名称
5. __CLASS__ // 类名称
6. __METHOD__ // 方法名称
7. __NAMESPACE__ // 当前命名空间
```

#### PHP 常用的魔术方法

```php
1. __construct()
2. __destruct()
3. __isset()
4. __toString()
5. __get()
6. __set()
7. __unset()
8. __clone()
9. __debugInfo()
```

#### 单点登录

session 共享来实现

#### 权限系统设计

- 用户
- 角色
- 权限
- 用户角色
- 角色权限

### MySQL

#### Sql 语句应该考虑哪些安全性

1. 防止 sql 注入，对特殊字符进行转义和过滤
2. 用最小权限原则，最好不用 root 连接数据库
3. 当 sql 运行出错时，不要把错误信息展示给用户

#### Sql 索引

1. 普通索引
2. 唯一索引
3. 主键索引
4. 复合索引

#### MySQL 索引的优缺点

1. 优点
   - 加快查询速度
   - 可以加速表与表之间的连接
   - 在使用分组和排序进行检索的时候，可以减少查询中分组和排序的时间
   - 减少服务器对数据的扫描
   - 帮助服务器避免排序和临时表
   - 将随机 I/O 变成顺序 I/O
2. 缺点
   - 占用磁盘空间
   - 对于写的操作，会降低速度
   - 创建和维护索引要消耗时间，这种时间随着数据量的增加而增加

#### MySQL 什么时候会产生临时表

1. union 查询
2. order by 和 group by 子句不一样
3. distinct 加上 order by 查询
4. from 中的子查询
5. 表连接中，order by 的列不是驱动表中的

#### 什么时候应该创建索引

1. 经常需要搜索的列上，可以加快搜索的速度
2. 做为主键的列上
3. 经常用在 where 子句上的列
4. 经常用做排序和分组的列
5. 经常用在连接的列上，主要是一些外键，可以加快连接的速度

#### 什么时候不需要创建索引

1. 查询中很少使用的列
2. 只有很少数据值的列
3. 经常进行增删改的列，频繁更新的列
4. 数据重复且平均分布的列，比如 男女

#### 什么时候索引失效

1. 条件中带有 or
2. like 模糊查询中以 % 开头
3. 如果列是字符串，没有用引号引用起来
4. 使用函数或者四则运算
5. 判断索引不是某个值 !=
6. not in 查询

#### char 和 varchar 的区别

- char 是定长，不管存储是否达到设定的值，都按设定的值存储，效率较高
- varchar 是变长，存储的字符要比 char 长
- char 的效率比 varchar 要高

#### 优化 SQL 语句

1. 尽量选择较少的列查询
2. 在 where 后面频繁使用的字段加上索引
3. 避免是用 select * 查询
4. 避免在索引列上做运算，使用 not in 和 <> 等操作
5. 合理的使用 limit
6. 合适表分割，在查询较慢的地方使用 explain 分析查询语句

#### MySQL 中的事务（ACID）

1. **原子性（A）**：一组 sql 要么全部成功要么全部失败
2. **一致性（C）**：一致的从一种状态改变为另一种状态
3. **隔离型（I）**：一个事务未完成之前不会被另一个事务读取
4. **持久性（D）**：一旦食物提交，数据就会永久写入系统

#### MySQL 优化

1. 选取合适的字段属性，字段的宽度尽可能的小
2. 用连接查询来替代子查询
3. 使用事务
4. 使用外键
5. 建立索引
6. 优化查询语句
7. 锁定表

#### 数据库的三大范式

1. 保证每一列都是不可再分的属性值，保证每一列的原子性，减少冗余
2. 保证每一列都必须依赖主键
3. 保证每一列都与主键有直接关系，而不是间接关系

#### 数据库内部实现机制

1. 

#### MySQL 脏读/虚读/幻读解决方法

解决方法：**通过事务的隔离级别（读未提交/读已提交/可重复读/串行化）**

- 脏读：指的是一个线程中的事务读取到另一个线程中未提交的数据（**读已提交**）
- 虚读：指的是一个线程中的事务读取到另一个线程中提交的 update 的数据（**可重复读/加锁**）
- 幻读：指的是一个线程中的事务读取到另一个线程中提交的 inster 的数据（**串行化**）

#### 数据库的存储引擎

- MyISAM
  - 插入数据快，空间和内存使用比较低
  - 不支持事务
  - 数据存储在文件中
  - 支持表级锁
- InnoDB
  - 支持事务/行锁/外键
  - 数据存储在共享表空间
  - 支持奔溃后修复
- Memory
  - 所有数据在内存中，数据处理速度快
  - 对表的大小有要求，不能建立太大的表
  - 安全性不高
- Archive
  - 适合查询和存储

#### 悲观锁和乐观锁

- 乐观锁：每次去拿数据都会认为别人不会修改数据，但是在更新数据的时候会判断在此期间有没有更新这个数据，**适合多读的场景**
- 悲观锁：每次去拿数据都会认为别人会修改数据，所以每次都拿数据都会上锁，**适合多写的操作**

#### 主从复制

##### 1. 基本过程

1. 主库在事务提交时会把数据更作事件记录在二进制文件 binlog 中，主库上的 sync_binlog 参数控制 binlog 日志刷新到磁盘中
2. 主库推送二进制文件 binlog 到从库的中继日志 relay-log，之后从库根据 relay log 日志做数据变更操作

##### 2. 主要的三个线程

- Binlog dump 线程（主库）
- I/O 线程（从库）
- SQL 线程（从库）

当从库上启动复制，首先创建 I/O 线程连接主库，主库随后创建 Binlog dump 线程读取数据库事件发送给 I/O 线程，I/O 线程读取到事件数据之后更新到从库的中继日志 Relay log 中，之后从库的 SQL 线程读取中继日志中更新的数据库事件并应用

##### 3. 三种复制方式

1. 基于 SQL 语句的复制

   每条修改数据的 SQL 都会保存在 binlog 日志中

2. 基于行的复制

   每行的数据变化都会记录到 binlog 日志中

3. 混合复制模式

   基于语句和行混合使用

##### 4. 复制的三种常见架构

1. 一主多从

   一个主库多个从库，读写分离，主库主要负责写和实时性较高的读的操作，从库主要负责读取的操作

2. 多级复制

   两个 master，多个 slave，其中一个 master 主要负责推送 binlog 日志到 slave

   **优点**：解决了主库的 I/O 负载和网络压力

   **缺点**：数据延时比较大（优化：master2 上选择 BLACKHOLE 引擎来降低延时，原理是 BLACKHOLE 表的数据不会写回到磁盘上，永远是空表，只用来记录 bin log 日志）

3. 双主复制

   两个 master 库，适合 DBA 做维护，master1 和 master2 互为主从，写的操作访问 master1 ，读的操作访问 master1 或者 master2

##### 5. 复制类型

- 异步复制

  数据库事务提交之后，在主库写入 bin log 日志就可以成功返回给客户端

- 半同步复制

  数据库事务提交之后，bin log 不仅要写在主库上，还要同时向从库推送，等到从库收到 bin log 日志后才会返回成功给客户端，如果从库长时间没有返回，则自动调整为异步复制

### Nginx

#### 负载均衡五种策略

1. 轮询（默认）

   每个请求按时间顺序逐一分配到不同后端服务器，如果服务器 down掉，能自动剔除

2. 权重（weight）

   指定轮询的几率，weight 和访问比率成正比

3. ip_hash

   解决用户登录信息丢失的情况，每次请求都定位到同一个服务器

4. Url_hash

   按 url 的 hash 结果来分配请求，使每个 url 定向到同一个对应的后端服务器

5. 第三方 fair

   按后端服务器响应时间来分配，响应时间短的优先分配

#### 反向代理

##### 1. 理解

反向代理是指代理服务器接收 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就变现为一个服务器

##### 2.为什么使用反向代理

- 可以起到保护网站安全的作用，因为任何来自 internet 的请求都必须先经过代理服务器
- 通过缓存静态资源，加速 web 请求
- 实现负载均衡

### Linux

#### Linux 的压缩和解压

- .tar.gz 和 .tgz 文件

  解压：tar zxvf filename

  压缩：tar zcvf filename

- .tar 文件

  解压：tar xvf filename

  压缩：tar cvf filename

```php
x:解压
v:显示全部过程
f:后面接文件
c:建立压缩文档
```

#### Linux 的基本命令

- ls 列表

- ln 软链

- touch 创建文件

- mkdir 创建文件夹

- mv 移动

- cp 复制

- cat 用于标准输出上查看文件内容

- vim 打开文件

- rm 删除

- cd 切换文件路径

- free 查看内存

  free -m 单位为兆

- top 查看 cpu 占用情况

- pwd 显示当前工作目录

- tail 标准输出默认显示文件的最后10行

- grep 在给定文件中搜寻指定的字符串

- ps 显示系统的运行进程

#### Linux 的文件权限

- 权限的粒度有 拥有者(u)/群组(g)/其他组(o) 三种
- 权限类型包括 读/写/执行 权限
- 读（r）：4；写（w）：2；执行（x）：1
- chmod u+rwx filename or chmod 700 filename

